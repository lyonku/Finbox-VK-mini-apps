{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"children\", \"slideWidth\", \"slideIndex\", \"isDraggable\", \"onDragStart\", \"onDragEnd\", \"onChange\", \"onEnd\", \"align\", \"bullets\", \"platform\", \"hasMouse\", \"showArrows\", \"window\", \"document\", \"getRef\", \"getRootRef\"],\n  _excluded2 = [\"initialSlideIndex\", \"children\", \"timeout\", \"onChange\"];\nimport { createScopedElement } from \"../../lib/jsxRuntime\";\nimport * as React from \"react\";\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { Touch } from \"../Touch/Touch\";\nimport { classNames } from \"../../lib/classNames\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { withDOM } from \"../../lib/dom\";\nimport { setRef } from \"../../lib/utils\";\nimport { withAdaptivity } from \"../../hoc/withAdaptivity\";\nimport HorizontalScrollArrow from \"../HorizontalScroll/HorizontalScrollArrow\";\nimport { clamp } from \"../../helpers/math\";\nimport { useTimeout } from \"../../hooks/useTimeout\";\nvar BaseGallery = /*#__PURE__*/function (_React$Component) {\n  _inherits(BaseGallery, _React$Component);\n  var _super = _createSuper(BaseGallery);\n  function BaseGallery(props) {\n    var _this;\n    _classCallCheck(this, BaseGallery);\n    _this = _super.call(this, props);\n    _defineProperty(_assertThisInitialized(_this), \"container\", null);\n    _defineProperty(_assertThisInitialized(_this), \"slidesStore\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"viewport\", null);\n    _defineProperty(_assertThisInitialized(_this), \"onStart\", function () {\n      _this.setState({\n        animation: false\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onMoveX\", function (e) {\n      if (_this.props.isDraggable && !_this.isFullyVisible) {\n        e.originalEvent.preventDefault();\n        if (e.isSlideX) {\n          _this.props.onDragStart && _this.props.onDragStart(e);\n          if (_this.state.deltaX !== e.shiftX || _this.state.dragging !== e.isSlideX) {\n            _this.setState({\n              deltaX: e.shiftX,\n              dragging: e.isSlideX\n            });\n          }\n        }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onEnd\", function (e) {\n      var _this$props$slideInde;\n      var targetIndex = e.isSlide ? _this.getTarget(e) : (_this$props$slideInde = _this.props.slideIndex) !== null && _this$props$slideInde !== void 0 ? _this$props$slideInde : 0;\n      _this.props.onDragEnd && _this.props.onDragEnd(e);\n      _this.setState({\n        deltaX: 0,\n        animation: true\n      }, function () {\n        var _this$props$onChange, _this$props;\n        return (_this$props$onChange = (_this$props = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props, targetIndex);\n      });\n      if (_this.props.onEnd) {\n        _this.props.onEnd({\n          targetIndex: targetIndex\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onResize\", function () {\n      return _this.initializeSlides({\n        animation: false\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slideLeft\", function () {\n      var _this$props2 = _this.props,\n        _this$props2$slideInd = _this$props2.slideIndex,\n        slideIndex = _this$props2$slideInd === void 0 ? 0 : _this$props2$slideInd,\n        onChange = _this$props2.onChange;\n      if (_this.canSlideLeft) {\n        _this.setState({\n          deltaX: 0,\n          animation: true\n        }, function () {\n          return onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex - 1);\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slideRight\", function () {\n      var _this$props3 = _this.props,\n        _this$props3$slideInd = _this$props3.slideIndex,\n        slideIndex = _this$props3$slideInd === void 0 ? 0 : _this$props3$slideInd,\n        onChange = _this$props3.onChange;\n      if (_this.canSlideRight) {\n        _this.setState({\n          deltaX: 0,\n          animation: true\n        }, function () {\n          return onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex + 1);\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getSlideRef\", function (id) {\n      return function (slide) {\n        _this.slidesStore[\"slide-\".concat(id)] = slide;\n      };\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getViewportRef\", function (viewport) {\n      _this.viewport = viewport;\n      if (_this.props.getRef) {\n        setRef(viewport, _this.props.getRef);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getRootRef\", function (container) {\n      _this.container = container;\n      if (_this.props.getRootRef) {\n        setRef(container, _this.props.getRootRef);\n      }\n    });\n    _this.state = {\n      containerWidth: 0,\n      deltaX: 0,\n      shiftX: 0,\n      slides: [],\n      animation: true,\n      duration: 0.24\n    };\n    _this.slidesStore = {};\n    return _this;\n  }\n  _createClass(BaseGallery, [{\n    key: \"isCenterWithCustomWidth\",\n    get: function get() {\n      return this.props.slideWidth === \"custom\" && this.props.align === \"center\";\n    }\n  }, {\n    key: \"initializeSlides\",\n    value: function initializeSlides() {\n      var _React$Children$map,\n        _this2 = this,\n        _this$container$offse,\n        _this$container;\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var slides = (_React$Children$map = React.Children.map(this.props.children, function (_item, i) {\n        var _elem$offsetLeft, _elem$offsetWidth;\n        var elem = _this2.slidesStore[\"slide-\".concat(i)];\n        return {\n          coordX: (_elem$offsetLeft = elem === null || elem === void 0 ? void 0 : elem.offsetLeft) !== null && _elem$offsetLeft !== void 0 ? _elem$offsetLeft : 0,\n          width: (_elem$offsetWidth = elem === null || elem === void 0 ? void 0 : elem.offsetWidth) !== null && _elem$offsetWidth !== void 0 ? _elem$offsetWidth : 0\n        };\n      })) !== null && _React$Children$map !== void 0 ? _React$Children$map : [];\n      var containerWidth = (_this$container$offse = (_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.offsetWidth) !== null && _this$container$offse !== void 0 ? _this$container$offse : 0;\n      var layerWidth = slides.reduce(function (val, slide) {\n        return slide.width + val;\n      }, 0);\n      var min = this.calcMin({\n        containerWidth: containerWidth,\n        layerWidth: layerWidth,\n        slides: slides\n      });\n      var max = this.calcMax({\n        slides: slides\n      });\n      this.setState({\n        min: min,\n        max: max,\n        layerWidth: layerWidth,\n        containerWidth: containerWidth,\n        slides: slides\n      }, function () {\n        if (_this2.props.slideIndex !== undefined) {\n          var shiftX = _this2.calculateIndent(_this2.props.slideIndex);\n          if (_this2.state.shiftX === shiftX) {\n            return;\n          }\n          var isValidShift = _this2.state.shiftX === _this2.validateIndent(_this2.state.shiftX);\n          var _options$animation = options.animation,\n            animation = _options$animation === void 0 ? isValidShift : _options$animation;\n          _this2.setState({\n            shiftX: shiftX,\n            animation: animation\n          }, function () {\n            if (!_this2.state.animation) {\n              var _this2$props$window;\n              (_this2$props$window = _this2.props.window) === null || _this2$props$window === void 0 ? void 0 : _this2$props$window.requestAnimationFrame(function () {\n                return _this2.setState({\n                  animation: true\n                });\n              });\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"calcMin\",\n    value: function calcMin(_ref) {\n      var _this$viewport$offset, _this$viewport;\n      var containerWidth = _ref.containerWidth,\n        _ref$layerWidth = _ref.layerWidth,\n        layerWidth = _ref$layerWidth === void 0 ? 0 : _ref$layerWidth,\n        slides = _ref.slides;\n      var viewportWidth = (_this$viewport$offset = (_this$viewport = this.viewport) === null || _this$viewport === void 0 ? void 0 : _this$viewport.offsetWidth) !== null && _this$viewport$offset !== void 0 ? _this$viewport$offset : 0;\n      switch (this.props.align) {\n        case \"left\":\n          return containerWidth - layerWidth;\n        case \"right\":\n          return viewportWidth - layerWidth;\n        case \"center\":\n          if (this.isCenterWithCustomWidth && slides.length) {\n            var _slides = slides[slides.length - 1],\n              coordX = _slides.coordX,\n              width = _slides.width;\n            return viewportWidth / 2 - coordX - width / 2;\n          } else {\n            return viewportWidth - (containerWidth - viewportWidth) / 2 - layerWidth;\n          }\n      }\n      return undefined;\n    }\n  }, {\n    key: \"calcMax\",\n    value: function calcMax(_ref2) {\n      var _this$viewport$offset2, _this$viewport2;\n      var slides = _ref2.slides;\n      var viewportWidth = (_this$viewport$offset2 = (_this$viewport2 = this.viewport) === null || _this$viewport2 === void 0 ? void 0 : _this$viewport2.offsetWidth) !== null && _this$viewport$offset2 !== void 0 ? _this$viewport$offset2 : 0;\n      if (this.isCenterWithCustomWidth && slides.length) {\n        var _slides$ = slides[0],\n          width = _slides$.width,\n          coordX = _slides$.coordX;\n        return viewportWidth / 2 - coordX - width / 2;\n      } else {\n        return 0;\n      }\n    }\n    /*\n     * Считает отступ слоя галереи\n     */\n  }, {\n    key: \"calculateIndent\",\n    value: function calculateIndent(targetIndex) {\n      var slides = this.state.slides;\n      if (this.isFullyVisible) {\n        return 0;\n      }\n      var targetSlide = slides.length ? slides[targetIndex] : null;\n      if (targetSlide) {\n        var coordX = targetSlide.coordX,\n          width = targetSlide.width;\n        if (this.isCenterWithCustomWidth) {\n          var _this$viewport$offset3, _this$viewport3;\n          var viewportWidth = (_this$viewport$offset3 = (_this$viewport3 = this.viewport) === null || _this$viewport3 === void 0 ? void 0 : _this$viewport3.offsetWidth) !== null && _this$viewport$offset3 !== void 0 ? _this$viewport$offset3 : 0;\n          return viewportWidth / 2 - coordX - width / 2;\n        }\n        return this.validateIndent(-1 * coordX);\n      } else {\n        return 0;\n      }\n    }\n    /*\n     * Считает отступ слоя галереи во время драга\n     */\n  }, {\n    key: \"calculateDragIndent\",\n    value: function calculateDragIndent() {\n      var _this$state = this.state,\n        shiftX = _this$state.shiftX,\n        deltaX = _this$state.deltaX,\n        _this$state$min = _this$state.min,\n        min = _this$state$min === void 0 ? 0 : _this$state$min,\n        _this$state$max = _this$state.max,\n        max = _this$state$max === void 0 ? 0 : _this$state$max;\n      var indent = shiftX + deltaX;\n      if (indent > max) {\n        return max + Number((indent - max) / 3);\n      } else if (indent < min) {\n        return min + Number((indent - min) / 3);\n      }\n      return indent;\n    }\n  }, {\n    key: \"validateIndent\",\n    value: function validateIndent(value) {\n      var _this$state2 = this.state,\n        _this$state2$min = _this$state2.min,\n        min = _this$state2$min === void 0 ? 0 : _this$state2$min,\n        _this$state2$max = _this$state2.max,\n        max = _this$state2$max === void 0 ? 0 : _this$state2$max;\n      if (value < min) {\n        return min;\n      } else if (value > max) {\n        return max;\n      }\n      return value;\n    }\n  }, {\n    key: \"isFullyVisible\",\n    get: function get() {\n      var _this$state$layerWidt;\n      return ((_this$state$layerWidt = this.state.layerWidth) !== null && _this$state$layerWidt !== void 0 ? _this$state$layerWidt : 0) <= this.state.containerWidth;\n    }\n    /*\n     * Получает индекс слайда, к которому будет осуществлен переход\n     */\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(e) {\n      var _this$state3 = this.state,\n        slides = _this$state3.slides,\n        deltaX = _this$state3.deltaX,\n        shiftX = _this$state3.shiftX,\n        _this$state3$max = _this$state3.max,\n        max = _this$state3$max === void 0 ? 0 : _this$state3$max;\n      var _this$props$slideInde2 = this.props.slideIndex,\n        slideIndex = _this$props$slideInde2 === void 0 ? 0 : _this$props$slideInde2;\n      var expectDeltaX = deltaX / e.duration * 240 * 0.6;\n      var shift = shiftX + deltaX + expectDeltaX - max;\n      var direction = deltaX < 0 ? 1 : -1; // Находим ближайшую границу слайда к текущему отступу\n\n      var targetIndex = slides.reduce(function (val, item, index) {\n        var previousValue = Math.abs(slides[val].coordX + shift);\n        var currentValue = Math.abs(item.coordX + shift);\n        return previousValue < currentValue ? val : index;\n      }, slideIndex);\n      if (targetIndex === slideIndex) {\n        var targetSlide = slideIndex + direction;\n        if (targetSlide >= 0 && targetSlide < slides.length) {\n          if (Math.abs(deltaX) > slides[targetSlide].width * 0.05) {\n            targetIndex = targetSlide;\n          }\n        }\n      }\n      return targetIndex;\n    }\n  }, {\n    key: \"canSlideLeft\",\n    get: function get() {\n      // shiftX is negative number <= 0, we can swipe back only if it is < 0\n      return !this.isFullyVisible && this.state.shiftX < 0;\n    }\n  }, {\n    key: \"canSlideRight\",\n    get: function get() {\n      var _this$state4 = this.state,\n        containerWidth = _this$state4.containerWidth,\n        _this$state4$layerWid = _this$state4.layerWidth,\n        layerWidth = _this$state4$layerWid === void 0 ? 0 : _this$state4$layerWid,\n        shiftX = _this$state4.shiftX,\n        slides = _this$state4.slides;\n      var _this$props4 = this.props,\n        align = _this$props4.align,\n        _this$props4$slideInd = _this$props4.slideIndex,\n        slideIndex = _this$props4$slideInd === void 0 ? 0 : _this$props4$slideInd;\n      return !this.isFullyVisible && (\n      // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side\n      align === \"left\" && containerWidth - shiftX < layerWidth ||\n      // otherwise we need to check current slide index (align = right or align = center)\n      align !== \"left\" && slideIndex < slides.length - 1);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.initializeSlides({\n        animation: false\n      });\n      this.props.window.addEventListener(\"resize\", this.onResize);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var widthChanged = this.props.slideWidth !== prevProps.slideWidth;\n      var isPropUpdate = this.props !== prevProps;\n      var slideCountChanged = React.Children.count(this.props.children) !== React.Children.count(prevProps.children);\n      var isCustomWidth = this.props.slideWidth === \"custom\"; // в любом из этих случаев позиция могла поменяться\n\n      if (widthChanged || slideCountChanged || isCustomWidth && isPropUpdate) {\n        this.initializeSlides();\n      } else if (this.props.slideIndex !== prevProps.slideIndex) {\n        var _this$props$slideInde3;\n        this.setState({\n          animation: true,\n          deltaX: 0,\n          shiftX: this.calculateIndent((_this$props$slideInde3 = this.props.slideIndex) !== null && _this$props$slideInde3 !== void 0 ? _this$props$slideInde3 : 0)\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.props.window.removeEventListener(\"resize\", this.onResize);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n      var _this$state5 = this.state,\n        animation = _this$state5.animation,\n        duration = _this$state5.duration,\n        dragging = _this$state5.dragging;\n      var _this$props5 = this.props,\n        children = _this$props5.children,\n        slideWidth = _this$props5.slideWidth,\n        _this$props5$slideInd = _this$props5.slideIndex,\n        slideIndex = _this$props5$slideInd === void 0 ? 0 : _this$props5$slideInd,\n        isDraggable = _this$props5.isDraggable,\n        onDragStart = _this$props5.onDragStart,\n        onDragEnd = _this$props5.onDragEnd,\n        onChange = _this$props5.onChange,\n        onEnd = _this$props5.onEnd,\n        align = _this$props5.align,\n        bullets = _this$props5.bullets,\n        platform = _this$props5.platform,\n        hasMouse = _this$props5.hasMouse,\n        showArrows = _this$props5.showArrows,\n        window = _this$props5.window,\n        document = _this$props5.document,\n        getRef = _this$props5.getRef,\n        getRootRef = _this$props5.getRootRef,\n        restProps = _objectWithoutProperties(_this$props5, _excluded);\n      var indent = dragging ? this.calculateDragIndent() : this.calculateIndent(slideIndex);\n      var layerStyle = {\n        WebkitTransform: \"translateX(\".concat(indent, \"px)\"),\n        transform: \"translateX(\".concat(indent, \"px)\"),\n        WebkitTransition: animation ? \"-webkit-transform \".concat(duration, \"s cubic-bezier(.1, 0, .25, 1)\") : \"none\",\n        transition: animation ? \"transform \".concat(duration, \"s cubic-bezier(.1, 0, .25, 1)\") : \"none\"\n      };\n      return createScopedElement(\"div\", _extends({}, restProps, {\n        vkuiClass: classNames(getClassName(\"Gallery\", platform), \"Gallery--\".concat(align), {\n          \"Gallery--dragging\": dragging,\n          \"Gallery--custom-width\": slideWidth === \"custom\"\n        }),\n        ref: this.getRootRef\n      }), createScopedElement(Touch, {\n        vkuiClass: \"Gallery__viewport\",\n        onStartX: this.onStart,\n        onMoveX: this.onMoveX,\n        onEnd: this.onEnd,\n        noSlideClick: true,\n        style: {\n          width: slideWidth === \"custom\" ? \"100%\" : slideWidth\n        },\n        getRootRef: this.getViewportRef\n      }, createScopedElement(\"div\", {\n        vkuiClass: \"Gallery__layer\",\n        style: layerStyle\n      }, React.Children.map(children, function (item, i) {\n        return createScopedElement(\"div\", {\n          vkuiClass: \"Gallery__slide\",\n          key: \"slide-\".concat(i),\n          ref: _this3.getSlideRef(i)\n        }, item);\n      }))), bullets && createScopedElement(\"div\", {\n        \"aria-hidden\": \"true\",\n        vkuiClass: classNames(\"Gallery__bullets\", \"Gallery__bullets--\".concat(bullets))\n      }, React.Children.map(children, function (_item, index) {\n        return createScopedElement(\"div\", {\n          vkuiClass: classNames(\"Gallery__bullet\", {\n            \"Gallery__bullet--active\": index === slideIndex\n          }),\n          key: index\n        });\n      })), showArrows && hasMouse && this.canSlideLeft && createScopedElement(HorizontalScrollArrow, {\n        direction: \"left\",\n        onClick: this.slideLeft\n      }), showArrows && hasMouse && this.canSlideRight && createScopedElement(HorizontalScrollArrow, {\n        direction: \"right\",\n        onClick: this.slideRight\n      }));\n    }\n  }]);\n  return BaseGallery;\n}(React.Component);\n_defineProperty(BaseGallery, \"defaultProps\", {\n  slideWidth: \"100%\",\n  children: \"\",\n  align: \"left\",\n  bullets: false,\n  isDraggable: true\n});\nvar BaseGalleryAdaptive = withAdaptivity(withDOM(BaseGallery), {\n  hasMouse: true\n});\nvar Gallery = function Gallery(_ref3) {\n  var _props$slideIndex;\n  var _ref3$initialSlideInd = _ref3.initialSlideIndex,\n    initialSlideIndex = _ref3$initialSlideInd === void 0 ? 0 : _ref3$initialSlideInd,\n    children = _ref3.children,\n    _ref3$timeout = _ref3.timeout,\n    timeout = _ref3$timeout === void 0 ? 0 : _ref3$timeout,\n    onChange = _ref3.onChange,\n    props = _objectWithoutProperties(_ref3, _excluded2);\n  var _React$useState = React.useState(initialSlideIndex),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    localSlideIndex = _React$useState2[0],\n    setSlideIndex = _React$useState2[1];\n  var isControlled = typeof props.slideIndex === \"number\";\n  var slideIndex = isControlled ? (_props$slideIndex = props.slideIndex) !== null && _props$slideIndex !== void 0 ? _props$slideIndex : 0 : localSlideIndex;\n  var isDraggable = !isControlled || Boolean(onChange);\n  var slides = React.Children.toArray(children).filter(function (item) {\n    return Boolean(item);\n  });\n  var childCount = slides.length;\n  var handleChange = React.useCallback(function (current) {\n    if (current === slideIndex) {\n      return;\n    }\n    !isControlled && setSlideIndex(current);\n    onChange && onChange(current);\n  }, [isControlled, onChange, slideIndex]);\n  var autoplay = useTimeout(function () {\n    return handleChange((slideIndex + 1) % childCount);\n  }, timeout);\n  React.useEffect(function () {\n    return timeout ? autoplay.set() : autoplay.clear();\n  }, [timeout, slideIndex, autoplay]); // prevent invalid slideIndex\n  // any slide index is invalid with no slides, just keep it as is\n\n  var safeSlideIndex = childCount > 0 ? clamp(slideIndex, 0, childCount - 1) : slideIndex; // notify parent in controlled mode\n\n  React.useEffect(function () {\n    if (onChange && safeSlideIndex !== slideIndex) {\n      onChange(safeSlideIndex);\n    }\n  }, [onChange, safeSlideIndex, slideIndex]);\n  return createScopedElement(BaseGalleryAdaptive, _extends({\n    isDraggable: isDraggable\n  }, props, {\n    slideIndex: safeSlideIndex,\n    onChange: handleChange\n  }), slides);\n}; // eslint-disable-next-line import/no-default-export\n\nexport default withPlatform(Gallery);","map":{"version":3,"mappings":"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","names":["React","getClassName","Touch","classNames","withPlatform","withDOM","setRef","withAdaptivity","HorizontalScrollArrow","clamp","useTimeout","BaseGallery","props","_classCallCheck","_this","_defineProperty","setState","animation","e","isDraggable","isFullyVisible","originalEvent","preventDefault","isSlideX","onDragStart","state","deltaX","shiftX","dragging","targetIndex","isSlide","getTarget","slideIndex","onDragEnd","onChange","_this$props$onChange","onEnd","initializeSlides","_this$props2$slideInd","canSlideLeft","_this$props3$slideInd","canSlideRight","id","slide","slidesStore","viewport","getRef","container","getRootRef","containerWidth","slides","duration","slideWidth","align","_this2","_this$container$offse","_this$container","options","Children","map","children","_item","i","elem","coordX","offsetLeft","width","offsetWidth","layerWidth","reduce","val","min","calcMin","max","calcMax","undefined","calculateIndent","isValidShift","validateIndent","window","requestAnimationFrame","_ref$layerWidth","viewportWidth","_this$viewport","isCenterWithCustomWidth","length","_this$viewport2","targetSlide","_this$viewport3","_this$state$min","_this$state$max","indent","Number","value","_this$state2$min","_this$state2$max","_this$state3$max","expectDeltaX","shift","direction","item","index","previousValue","Math","abs","currentValue","_this$state4$layerWid","_this$props4$slideInd","addEventListener","onResize","prevProps","widthChanged","isPropUpdate","slideCountChanged","count","isCustomWidth","removeEventListener","_this$props5$slideInd","bullets","platform","hasMouse","showArrows","document","restProps","calculateDragIndent","layerStyle","WebkitTransform","transform","WebkitTransition","transition","createScopedElement","vkuiClass","ref","onStartX","onStart","onMoveX","noSlideClick","style","getViewportRef","key","_this3","getSlideRef","onClick","slideLeft","slideRight","Component","BaseGalleryAdaptive","Gallery","initialSlideIndex","_ref3$timeout","timeout","useState","_React$useState2","localSlideIndex","setSlideIndex","isControlled","Boolean","toArray","filter","childCount","handleChange","useCallback","current","autoplay","useEffect","set","clear","safeSlideIndex"],"sources":["../../../src/components/Gallery/Gallery.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { Touch, TouchEventHandler, TouchEvent } from \"../Touch/Touch\";\nimport { classNames } from \"../../lib/classNames\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { HasAlign, HasPlatform, HasRef, HasRootRef } from \"../../types\";\nimport { withDOM, DOMProps } from \"../../lib/dom\";\nimport { setRef } from \"../../lib/utils\";\nimport { withAdaptivity, AdaptivityProps } from \"../../hoc/withAdaptivity\";\nimport HorizontalScrollArrow from \"../HorizontalScroll/HorizontalScrollArrow\";\nimport { clamp } from \"../../helpers/math\";\nimport { useTimeout } from \"../../hooks/useTimeout\";\nimport \"./Gallery.css\";\n\nexport interface BaseGalleryProps\n  extends Omit<\n      React.HTMLAttributes<HTMLDivElement>,\n      \"onChange\" | \"onDragStart\" | \"onDragEnd\"\n    >,\n    HasPlatform,\n    HasAlign,\n    HasRootRef<HTMLDivElement>,\n    HasRef<HTMLElement> {\n  slideWidth?: string | number;\n  slideIndex?: number;\n  onDragStart?: TouchEventHandler;\n  onDragEnd?: TouchEventHandler;\n  onChange?(current: number): void;\n  onEnd?({ targetIndex }: { targetIndex: number }): void;\n  bullets?: \"dark\" | \"light\" | false;\n  isDraggable?: boolean;\n  showArrows?: boolean;\n}\n\nexport interface GalleryProps extends BaseGalleryProps {\n  initialSlideIndex?: number;\n  timeout?: number;\n}\n\nexport interface GalleryState {\n  containerWidth: number;\n  layerWidth?: number;\n  min?: number;\n  max?: number;\n  deltaX: number;\n  shiftX: number;\n  slides: GallerySlidesState[];\n  animation: boolean;\n  duration: number;\n  dragging?: boolean;\n}\n\nexport interface GallerySlidesState {\n  coordX: number;\n  width: number;\n}\n\ntype GetSlideRef = (index: number) => React.RefCallback<HTMLElement>;\n\nclass BaseGallery extends React.Component<\n  BaseGalleryProps & DOMProps & AdaptivityProps,\n  GalleryState\n> {\n  constructor(props: GalleryProps) {\n    super(props);\n\n    this.state = {\n      containerWidth: 0,\n      deltaX: 0,\n      shiftX: 0,\n      slides: [],\n      animation: true,\n      duration: 0.24,\n    };\n\n    this.slidesStore = {};\n  }\n\n  container: HTMLDivElement | null = null;\n  slidesStore: {\n    [index: string]: HTMLElement | null;\n  };\n  viewport: HTMLElement | null = null;\n\n  static defaultProps: Partial<BaseGalleryProps> = {\n    slideWidth: \"100%\",\n    children: \"\",\n    align: \"left\",\n    bullets: false,\n    isDraggable: true,\n  };\n\n  get isCenterWithCustomWidth() {\n    return this.props.slideWidth === \"custom\" && this.props.align === \"center\";\n  }\n\n  initializeSlides(options: { animation?: boolean } = {}) {\n    const slides =\n      React.Children.map(\n        this.props.children,\n        (_item: React.ReactNode, i: number): GallerySlidesState => {\n          const elem = this.slidesStore[`slide-${i}`];\n          return {\n            coordX: elem?.offsetLeft ?? 0,\n            width: elem?.offsetWidth ?? 0,\n          };\n        }\n      ) ?? [];\n\n    const containerWidth = this.container?.offsetWidth ?? 0;\n    const layerWidth = slides.reduce(\n      (val: number, slide: GallerySlidesState) => slide.width + val,\n      0\n    );\n\n    const min = this.calcMin({ containerWidth, layerWidth, slides });\n    const max = this.calcMax({ slides });\n\n    this.setState({ min, max, layerWidth, containerWidth, slides }, () => {\n      if (this.props.slideIndex !== undefined) {\n        const shiftX = this.calculateIndent(this.props.slideIndex);\n        if (this.state.shiftX === shiftX) {\n          return;\n        }\n        const isValidShift =\n          this.state.shiftX === this.validateIndent(this.state.shiftX);\n        const { animation = isValidShift } = options;\n        this.setState({ shiftX, animation }, () => {\n          if (!this.state.animation) {\n            this.props.window?.requestAnimationFrame(() =>\n              this.setState({ animation: true })\n            );\n          }\n        });\n      }\n    });\n  }\n\n  calcMin({\n    containerWidth,\n    layerWidth = 0,\n    slides,\n  }: Pick<GalleryState, \"containerWidth\" | \"layerWidth\" | \"slides\">) {\n    const viewportWidth = this.viewport?.offsetWidth ?? 0;\n    switch (this.props.align) {\n      case \"left\":\n        return containerWidth - layerWidth;\n      case \"right\":\n        return viewportWidth - layerWidth;\n      case \"center\":\n        if (this.isCenterWithCustomWidth && slides.length) {\n          const { coordX, width } = slides[slides.length - 1];\n          return viewportWidth / 2 - coordX - width / 2;\n        } else {\n          return (\n            viewportWidth - (containerWidth - viewportWidth) / 2 - layerWidth\n          );\n        }\n    }\n    return undefined;\n  }\n\n  calcMax({ slides }: Pick<GalleryState, \"slides\">) {\n    const viewportWidth = this.viewport?.offsetWidth ?? 0;\n    if (this.isCenterWithCustomWidth && slides.length) {\n      const { width, coordX } = slides[0];\n      return viewportWidth / 2 - coordX - width / 2;\n    } else {\n      return 0;\n    }\n  }\n\n  /*\n   * Считает отступ слоя галереи\n   */\n  calculateIndent(targetIndex: number) {\n    const { slides } = this.state;\n\n    if (this.isFullyVisible) {\n      return 0;\n    }\n\n    const targetSlide = slides.length ? slides[targetIndex] : null;\n\n    if (targetSlide) {\n      const { coordX, width } = targetSlide;\n\n      if (this.isCenterWithCustomWidth) {\n        const viewportWidth = this.viewport?.offsetWidth ?? 0;\n        return viewportWidth / 2 - coordX - width / 2;\n      }\n\n      return this.validateIndent(-1 * coordX);\n    } else {\n      return 0;\n    }\n  }\n\n  /*\n   * Считает отступ слоя галереи во время драга\n   */\n  calculateDragIndent() {\n    const { shiftX, deltaX, min = 0, max = 0 } = this.state;\n    const indent = shiftX + deltaX;\n\n    if (indent > max) {\n      return max + Number((indent - max) / 3);\n    } else if (indent < min) {\n      return min + Number((indent - min) / 3);\n    }\n\n    return indent;\n  }\n\n  validateIndent(value: number) {\n    const { min = 0, max = 0 } = this.state;\n\n    if (value < min) {\n      return min;\n    } else if (value > max) {\n      return max;\n    }\n\n    return value;\n  }\n\n  get isFullyVisible() {\n    return (this.state.layerWidth ?? 0) <= this.state.containerWidth;\n  }\n\n  /*\n   * Получает индекс слайда, к которому будет осуществлен переход\n   */\n  getTarget(e: TouchEvent) {\n    const { slides, deltaX, shiftX, max = 0 } = this.state;\n    const { slideIndex = 0 } = this.props;\n    const expectDeltaX = (deltaX / e.duration) * 240 * 0.6;\n    const shift = shiftX + deltaX + expectDeltaX - max;\n    const direction = deltaX < 0 ? 1 : -1;\n\n    // Находим ближайшую границу слайда к текущему отступу\n    let targetIndex = slides.reduce(\n      (val: number, item: GallerySlidesState, index: number) => {\n        const previousValue = Math.abs(slides[val].coordX + shift);\n        const currentValue = Math.abs(item.coordX + shift);\n\n        return previousValue < currentValue ? val : index;\n      },\n      slideIndex\n    );\n\n    if (targetIndex === slideIndex) {\n      let targetSlide = slideIndex + direction;\n\n      if (targetSlide >= 0 && targetSlide < slides.length) {\n        if (Math.abs(deltaX) > slides[targetSlide].width * 0.05) {\n          targetIndex = targetSlide;\n        }\n      }\n    }\n\n    return targetIndex;\n  }\n\n  onStart: TouchEventHandler = () => {\n    this.setState({\n      animation: false,\n    });\n  };\n\n  onMoveX: TouchEventHandler = (e: TouchEvent) => {\n    if (this.props.isDraggable && !this.isFullyVisible) {\n      e.originalEvent.preventDefault();\n\n      if (e.isSlideX) {\n        this.props.onDragStart && this.props.onDragStart(e);\n\n        if (\n          this.state.deltaX !== e.shiftX ||\n          this.state.dragging !== e.isSlideX\n        ) {\n          this.setState({\n            deltaX: e.shiftX,\n            dragging: e.isSlideX,\n          });\n        }\n      }\n    }\n  };\n\n  onEnd: TouchEventHandler = (e: TouchEvent) => {\n    const targetIndex = e.isSlide\n      ? this.getTarget(e)\n      : this.props.slideIndex ?? 0;\n    this.props.onDragEnd && this.props.onDragEnd(e);\n    this.setState({ deltaX: 0, animation: true }, () =>\n      this.props.onChange?.(targetIndex)\n    );\n\n    if (this.props.onEnd) {\n      this.props.onEnd({ targetIndex });\n    }\n  };\n\n  onResize: VoidFunction = () => this.initializeSlides({ animation: false });\n\n  get canSlideLeft() {\n    // shiftX is negative number <= 0, we can swipe back only if it is < 0\n    return !this.isFullyVisible && this.state.shiftX < 0;\n  }\n\n  get canSlideRight() {\n    const { containerWidth, layerWidth = 0, shiftX, slides } = this.state;\n    const { align, slideIndex = 0 } = this.props;\n    return (\n      !this.isFullyVisible &&\n      // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side\n      ((align === \"left\" && containerWidth - shiftX < layerWidth) ||\n        // otherwise we need to check current slide index (align = right or align = center)\n        (align !== \"left\" && slideIndex < slides.length - 1))\n    );\n  }\n\n  slideLeft = () => {\n    const { slideIndex = 0, onChange } = this.props;\n    if (this.canSlideLeft) {\n      this.setState({ deltaX: 0, animation: true }, () =>\n        onChange?.(slideIndex - 1)\n      );\n    }\n  };\n\n  slideRight = () => {\n    const { slideIndex = 0, onChange } = this.props;\n    if (this.canSlideRight) {\n      this.setState({ deltaX: 0, animation: true }, () =>\n        onChange?.(slideIndex + 1)\n      );\n    }\n  };\n\n  getSlideRef: GetSlideRef = (id: number) => (slide) => {\n    this.slidesStore[`slide-${id}`] = slide;\n  };\n\n  getViewportRef: React.RefCallback<HTMLElement> = (viewport) => {\n    this.viewport = viewport;\n    if (this.props.getRef) {\n      setRef(viewport, this.props.getRef);\n    }\n  };\n\n  getRootRef: React.RefCallback<HTMLDivElement> = (container) => {\n    this.container = container;\n    if (this.props.getRootRef) {\n      setRef(container, this.props.getRootRef);\n    }\n  };\n\n  componentDidMount() {\n    this.initializeSlides({ animation: false });\n    this.props.window!.addEventListener(\"resize\", this.onResize);\n  }\n\n  componentDidUpdate(prevProps: GalleryProps) {\n    const widthChanged = this.props.slideWidth !== prevProps.slideWidth;\n    const isPropUpdate = this.props !== prevProps;\n    const slideCountChanged =\n      React.Children.count(this.props.children) !==\n      React.Children.count(prevProps.children);\n    const isCustomWidth = this.props.slideWidth === \"custom\";\n\n    // в любом из этих случаев позиция могла поменяться\n    if (widthChanged || slideCountChanged || (isCustomWidth && isPropUpdate)) {\n      this.initializeSlides();\n    } else if (this.props.slideIndex !== prevProps.slideIndex) {\n      this.setState({\n        animation: true,\n        deltaX: 0,\n        shiftX: this.calculateIndent(this.props.slideIndex ?? 0),\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.window!.removeEventListener(\"resize\", this.onResize);\n  }\n\n  render() {\n    const { animation, duration, dragging } = this.state;\n    const {\n      children,\n      slideWidth,\n      slideIndex = 0,\n      isDraggable,\n      onDragStart,\n      onDragEnd,\n      onChange,\n      onEnd,\n      align,\n      bullets,\n      platform,\n      hasMouse,\n      showArrows,\n      window,\n      document,\n      getRef,\n      getRootRef,\n      ...restProps\n    } = this.props;\n\n    const indent = dragging\n      ? this.calculateDragIndent()\n      : this.calculateIndent(slideIndex);\n\n    const layerStyle = {\n      WebkitTransform: `translateX(${indent}px)`,\n      transform: `translateX(${indent}px)`,\n      WebkitTransition: animation\n        ? `-webkit-transform ${duration}s cubic-bezier(.1, 0, .25, 1)`\n        : \"none\",\n      transition: animation\n        ? `transform ${duration}s cubic-bezier(.1, 0, .25, 1)`\n        : \"none\",\n    };\n\n    return (\n      <div\n        {...restProps}\n        vkuiClass={classNames(\n          getClassName(\"Gallery\", platform),\n          `Gallery--${align}`,\n          {\n            \"Gallery--dragging\": dragging,\n            \"Gallery--custom-width\": slideWidth === \"custom\",\n          }\n        )}\n        ref={this.getRootRef}\n      >\n        <Touch\n          vkuiClass=\"Gallery__viewport\"\n          onStartX={this.onStart}\n          onMoveX={this.onMoveX}\n          onEnd={this.onEnd}\n          noSlideClick\n          style={{ width: slideWidth === \"custom\" ? \"100%\" : slideWidth }}\n          getRootRef={this.getViewportRef}\n        >\n          <div vkuiClass=\"Gallery__layer\" style={layerStyle}>\n            {React.Children.map(\n              children,\n              (item: React.ReactNode, i: number) => (\n                <div\n                  vkuiClass=\"Gallery__slide\"\n                  key={`slide-${i}`}\n                  ref={this.getSlideRef(i)}\n                >\n                  {item}\n                </div>\n              )\n            )}\n          </div>\n        </Touch>\n\n        {bullets && (\n          <div\n            aria-hidden=\"true\"\n            vkuiClass={classNames(\n              \"Gallery__bullets\",\n              `Gallery__bullets--${bullets}`\n            )}\n          >\n            {React.Children.map(\n              children,\n              (_item: React.ReactNode, index: number) => (\n                <div\n                  vkuiClass={classNames(\"Gallery__bullet\", {\n                    \"Gallery__bullet--active\": index === slideIndex,\n                  })}\n                  key={index}\n                />\n              )\n            )}\n          </div>\n        )}\n\n        {showArrows && hasMouse && this.canSlideLeft && (\n          <HorizontalScrollArrow direction=\"left\" onClick={this.slideLeft} />\n        )}\n        {showArrows && hasMouse && this.canSlideRight && (\n          <HorizontalScrollArrow direction=\"right\" onClick={this.slideRight} />\n        )}\n      </div>\n    );\n  }\n}\n\nconst BaseGalleryAdaptive = withAdaptivity(withDOM(BaseGallery), {\n  hasMouse: true,\n});\n\nconst Gallery: React.FC<GalleryProps> = ({\n  initialSlideIndex = 0,\n  children,\n  timeout = 0,\n  onChange,\n  ...props\n}: GalleryProps) => {\n  const [localSlideIndex, setSlideIndex] = React.useState(initialSlideIndex);\n  const isControlled = typeof props.slideIndex === \"number\";\n  const slideIndex = isControlled ? props.slideIndex ?? 0 : localSlideIndex;\n  const isDraggable = !isControlled || Boolean(onChange);\n  const slides = React.Children.toArray(children).filter((item) =>\n    Boolean(item)\n  );\n  const childCount = slides.length;\n\n  const handleChange: GalleryProps[\"onChange\"] = React.useCallback(\n    (current) => {\n      if (current === slideIndex) {\n        return;\n      }\n      !isControlled && setSlideIndex(current);\n      onChange && onChange(current);\n    },\n    [isControlled, onChange, slideIndex]\n  );\n\n  const autoplay = useTimeout(\n    () => handleChange((slideIndex + 1) % childCount),\n    timeout\n  );\n  React.useEffect(\n    () => (timeout ? autoplay.set() : autoplay.clear()),\n    [timeout, slideIndex, autoplay]\n  );\n\n  // prevent invalid slideIndex\n  // any slide index is invalid with no slides, just keep it as is\n  const safeSlideIndex =\n    childCount > 0 ? clamp(slideIndex, 0, childCount - 1) : slideIndex;\n  // notify parent in controlled mode\n  React.useEffect(() => {\n    if (onChange && safeSlideIndex !== slideIndex) {\n      onChange(safeSlideIndex);\n    }\n  }, [onChange, safeSlideIndex, slideIndex]);\n\n  return (\n    <BaseGalleryAdaptive\n      isDraggable={isDraggable}\n      {...props}\n      slideIndex={safeSlideIndex}\n      onChange={handleChange}\n    >\n      {slides}\n    </BaseGalleryAdaptive>\n  );\n};\n\n// eslint-disable-next-line import/no-default-export\nexport default withPlatform(Gallery);\n"]},"metadata":{},"sourceType":"module"}